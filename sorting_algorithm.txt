A sorting algorithm is an algorithm that puts elements of a list in a certain order. 
The most-used orders are numerical order and lexicographical order. 
Efficient sorting is important for optimizing the use of other algorithms (such as search and merge algorithms) which require input data to be in sorted lists

Classification of Sorting Algorithms :
	1. Computational complexity of element comparision
	2. Computational complexity of swaps - inplace algorithms
	3. Memory usage of algorithms whether inplace i.e need only constant space of O(1).
	4. Recursion Nature of the algorithm
	5. Stable sort or not
	6. Comparison sort or not
	7. Method of sorting
	    i   - insertion
	    ii  - exchange ["bubble sort", "quick sort", ..]
	    iii - selection ["shaker sort", "heap sort", ..]
	    iv  - merging
	8. Serial or Parallel
	9. Adaptability - ex,. whether presorted input affects the performance of algorithm

Stability :

    Naive definition:
        1. When sorting data with repeated elements, element that first occurs in the original list will come first after sorting

    Why its important ?
        Note - Repeated element is a vague definition. It should be phrased as element with same sorting key

        Same sorting key doesn't mean that the original item is same -> Then in certain cases stability becomes important

    Proper Definition:

        When sorting some kinds of data, only part of the data is examined when determining the sort order.
        This allows the possibility of multiple different correctly sorted versions of the original list.
        Stable sorting algorithms choose one of these, by preserving the relative order

Key :
    The part of the data used to compare.

When stability doesn't matters ?
    when elements with same keys becomes indistinguishable or any data where the entire element is key
    then stability doesn't matters

Possibility of making an unstable algorithm into a stable one:
    Unstable sorting algorithms can be specially implemented to be stable.
    One way of doing this is to artificially extend the key comparison,
    so that comparisons between two objects with otherwise equal keys are decided
    using the order of the entries in the original input list as a tie-breaker.
    Remembering this order, however, may require additional time and space.